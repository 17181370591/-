#参考资料https://blog.csdn.net/guzhou_diaoke/article/details/81045551#commentBox
''' 
有双插口和三插口的插线板。墙壁上只有1个插座能用,而需要用电的电器有20台,求方法数。
使用同一个插线板时,不考虑插口位置,只考虑插线板的连接方法。
如果3孔插线板上插了1个2孔a和1个3孔b，a和b后面没有插线板，那么a和b怎么插都只算一种。
当 n = 1 时,有 0 种插线板插线方法
当 n = 2 时,有 1 种插线板插线方法
当 n = 3 时,有 2 种插线板插线方法
当 n = 4 时,有 4 种插线板插线方法
当 n = 5 时,有 9 种插线板插线方法
下面的方法n=1时返回1，因为这里是为了处理方便临界点，不然下面的遍历需要多写很多。

分析：带记忆的DFS

c*(c+1)/2和c*(c+1)*(c+2)/6的由来：
Q1：考虑还需要n*m个孔，分成m路，每路都生成n个孔，已知dfs(n)=c，求方法数。
这里m=2的答案是c*(c+1)/2，m=3的答案是c*(c+1)*(c+2)/6。

Q1可以转换成Q2：
有c个不同的数，随机选择一个并记录，重复m次，把m个结果排序后得到队伍a，
求a可能值的个数。如c=4(假设数是1,2,3,4),m=3时答案是20，a的可能值是：
111,222,333,444,
112,122,113,133,114,144,223,233,224,244,334,344
123,124,134,234

Q2可以转换成Q3：
有c+m-1个'不同'的数，随机m个排序后去重，求剩余方法数。
c+m-1个数分别是(1,2,....,c,X1,X2,....,X（m-1） )，
选取m个数依旧按这个顺序排序得到队伍a，如果队伍里有Xk，Xk就等于a的第k个数，
比如c=10,m=6，a=[3,5,9,X1,X3,X5],那么a=[3,5,9,3,9,9]=[3,3,5,9,9,9]，
这样能建立和Q2结果的一一映射。

'''
def dfs(n):
    if n==1:
        return 1
    if n in res.keys():
        return res[n]
    cnt=0
    for i in range(1,n//2+1):
        if i==n/2:
            c=dfs(i)
            cnt+=c*(c+1)/2
        else:
            cnt+=dfs(i)*dfs(n-i)
    for i in range(1,n//3+1):
        for j in range(i,(n-i)//2+1):
            if i==j and i==n-i-j:
                c=dfs(i)
                cnt+=c*(c+1)*(c+2)/6
            elif i==j or i==n-i-j:
                c=dfs(i)
                cnt+=c*(c+1)/2*dfs(n-i*2)
            elif j==n-i-j:
                c=dfs(j)
                cnt+=c*(c+1)/2*dfs(n-j*2)
            else:
                cnt+=dfs(i)*dfs(j)*dfs(n-i-j)
    res[n]=cnt
    return cnt

res={}
n=20
print(dfs(n))                   #63877262.0
